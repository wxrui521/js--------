###js常见问题以及常用语法：

1.浮点的精度问题：

	在默认的情况下，es会将小数点后面带有6个0以上的浮点数值转换为以e表示的数值

	浮点数值的最高精度是17位小数，但在进行计算的时候其精度远远不如整数

    例如： 0.1+0.2的结果不是0.3 而是0.30000000000000004，所以不要做这样的判断。有些有有些没有。		

2.for-in

	该语句是一种精准的迭代语句，可以用来枚举对象的属性。

3.label语句和break/continue语句的使用

4.将代码的作用域设置到一个特定的对象中。（）严格模式不使用

#####函数

1.位于return语句之后的任何代码永远都不会执行 （若直接return 会返回undefined）

2.函数参数内部通过arguments对象来访问采参数（严格模式下为其赋值无效）

3.没有重载（因为其参数由包含零或多个值的数组表示，没有函数签名）若两个名字相同，则属于后者

基本数据类型： Undefined Null Boolean Number String    复杂数据类型： Object


#####变量、作用域和内存的问题

1.引用类型是按照引用来访问的

2.typeof 判断基本类型  instaceof判断什么类型的对象

3.执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。（变量对象）（环境栈）（执行流）

4.当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。（保证对执行环境有权访问的所有变量和函数的有序访问）

5.没有块级作用域  (尤其是for循环，会导致声明的变量i可以在循环外部的执行环境得到访问)

6.垃圾收集： 1.标记清除(变量是否在环境中)  2.引用计数(引用类型的值赋给一个变量(问题是循环引用))

7.管理内存： 一旦数据不再有用，就将其设置为null来释放其引用（尤其是全局变量）


#####杂项小插曲

	jade语法中遍历某个下表用each i, item in dataList

	事件冒泡可以在较低级别的处理器中避免重复相同的代码

	css: overflow(当内容溢出元素框时发生的事情)

	defer之后会调用调用者同级的回调函数

	对于resolve、reject只是对应处理相应的方法。


#####引用类型

1.Object(1.new Object();构造函数   2.对象字面量)

2.Array类型： 1.构造函数   2.字面量

	Array下常用的方法：

	Array.isArray(Array);判断是否为Array   toString()方法     join()方法

	栈方法：（后进先出） push()方法   pop()方法

	队列方法：（先进先出） push()  shift()   unshift()从前端加项

	重排序方法： reverse()  会反转数组项的顺序  sort()  按升序排列数组项（其比较的是字符串，可以传一个函数从而进行比较）

	操作方法： concat()方法  将新的参数添加到数组中  slice() 基于当前数组中的一个或多个创建一个新数组 
    
                 splice()数组的最强大的方法 1.删除  传入2个参数 要删除的第一项的位置和要删除的项数
                    
                                                          				 2.插入  传入3个参数  可以向指定位置插入任意数				   量的项  splice(2,0,'red','green')

                                                          				 3.替换   传入3个参数  可以向指定位置插入任意数   				   量的项，且同时删除任意数量的项

                 （返回的是从从数组中删除的项）

	位置方法： indexOf()  lastIndexOf()  传递的参数 ： 要查找的项和查找起点位置的索引（使用的是 ===符号）

	迭代方法：（接受两个参数，在每一项运行的函数和运行该函数的作用域对象-影响this的值） 

	every filter some 放法多用于过滤 map多用于对每一项进行操作并返回数组   forEach 对于对每一项进行操作，而没有返回值

                   1.every()  对数组的每一项运行给定的函数，如果每一项都返回true，则返回true

                   2.filter()  对数组的每一项运行给定的函数，则返回函数会返回true组成的数组

                   3.forEach()  对数组中的每一项运行指定的函数，方法没有返回值

                   4.map()  对数组中的每一下个运行指定的函数，返回每次函数调用的结果组成的数组

                   5.some()  对数组中的每一项运行给定的函数，如果该函数对任一项返回true,则返回true

	归并方法： reduce()和reduceRight()
			
					传递四个参数 前一个值 当前值 项的索引 数组对象   第一次迭代发生在数组的第二项上，前一次的返回值作为参数传入到下一次中

3.Date类型

	new Date()   Date.now()   +new Date()




	null: "表示没有对象"，即该处不应该有值
          1.作为函数的参数，表示函数的参数不是对象
          2.作为对象原型链的终点
	undefined: 表示缺少值，就是此处应该有一个值，但是还没有定义
          1.变量被声明了，但没有赋值，就等于undefined
          2.调用函数时，应该提供的参数没有提供，该参数等于undefined
          3对象没有赋值的属性，该属性的值为undefined
          4.函数没有返回值时，默认返回undefined.

	通过对象将对象的键保存到一个数组中，获取对象的长度

	Object.keys(object);


4.继承方法：

	toLocalString()  toString()方法  
	valueof()  返回表示日期的毫秒  因此日期可以直接比较大小

	日期/时间组件方法
		getTime()  返回表示日期的毫秒数  
		setTime(毫秒)以毫秒设置日期，会改变整个日期
	 	getFullYear()  取得四位数的年份
		getMonth() 返回日期中的年份 
		getDate() 返回日期中的天数
		getDay()  返回日期中的星期的星期几/
		getHours() 返回日期中的小时数
		getMinutes()  日期中的分钟数
		getSeconds()  返回日期中的秒数

5.RegExp类型

	var expression = / pattern / flags ;
	g: 表示全局模式 即模式将被应用与所有的字符串，在非发现第一个匹配项时立即停止
	i: 表示不区分大小写  即在确定匹配模式时忽略与字符串的大小写
	m: 表示多行模式，在到达一行文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。

	var pattrern1 = /at/g;  匹配字符串中所有'at'的实例

	var pattern2 = /[bc]at/i; 匹配第一个bat或者cat ，不区分大小写

	var pattern3 = /.at/gi; 匹配所有以'at'结尾的3个字符组合，不区分大小写 

	元字符必须转义： ([{\^$|}])?*+.

	var pattern = /\[bc\]at/i  匹配第一个"[bc]at", 不区分大小写

	var pattern = new RegExp("[bc]at", "i");

	使用正则表达式和使用RegExp构造函数创建的正则表达式不一样。字面量会共同一个RegExp的实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。 （实例的属性不会重置）

	实例方法：

		exec(): 专门为捕获组而设计的

		调用该方法： 在不设置g时，其只会捕获第一个匹配项  设置g 再次调用时，会继续查找新的匹配项；

		test(): 在模式与该参数匹配的情况下返回true  

	^ $ 匹配开始和结束的情况


6.Function 类型：（函数是对象，因此函数名实际上是指向函数对象的指针，不会与某个函数绑定）

	1.函数声明语法  2.定义变量  3.构造函数的方式

	2.没有重载  覆盖了前面的引用

	3.函数声明和函数表达式
		
		函数声明提升

			函数声明： 解析器率先读取，在执行任何代码之前可以用(可以访问)
			函数表达式: 解析器执行到所在的代码行时才会真正的执行
		
	4.作为值的函数（要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号）

	5.函数内部的属性
	
		arguments: 一个类数组对象  包含着传入函数的所有参数 保存函数参数
		callee属性为指针，指向拥有这个arguments对象的函数（可以解决递归的紧密耦合的现象）

			function factorial(num) {
				if(num <= 1) {
					return 1;
				} else {
					return num * arguments.callee(num-1);
				}
			}

					
		